import Fastify from "fastify";
import fastifyWebsocket from "@fastify/websocket";
import fastifyCors from "@fastify/cors";
import type { WebSocket } from "ws";
import { loadConfig } from "./config.js";
import { createAuthHook, AttachTokens, verifyPsk, isValidSessionId } from "./auth.js";
import { SessionDiscovery } from "./sessions/discovery.js";
import { TmuxManager } from "./tmux/manager.js";
import { TerminalBridge } from "./terminal/bridge.js";
import { registerStatusRoutes } from "./routes/status.js";
import { registerSessionRoutes } from "./routes/sessions.js";
import { registerAttachRoutes } from "./routes/attach.js";

async function main(): Promise<void> {
  const config = loadConfig();

  if (!config.auth.psk) {
    console.error(
      "ERROR: No PSK configured. Edit ~/.config/claude-relay/config.yaml and set auth.psk",
    );
    process.exit(1);
  }

  const app = Fastify({
    logger: {
      level: process.env.LOG_LEVEL ?? "info",
      transport:
        process.env.NODE_ENV !== "production"
          ? { target: "pino-pretty", options: { colorize: true } }
          : undefined,
    },
  });

  const log = app.log;

  // CORS for mobile WebView
  await app.register(fastifyCors, {
    origin: true, // Allow all origins (single-user, VPN-only)
    methods: ["GET", "POST"],
  });

  // Register WebSocket support
  await app.register(fastifyWebsocket);

  // Auth hook for REST routes (WS has its own auth via attach tokens)
  const authHook = createAuthHook(config);
  app.addHook("onRequest", authHook);

  // Initialize services
  const discovery = new SessionDiscovery(config, log);
  const bridge = new TerminalBridge(config, log);
  // TmuxManager uses bridge as single source of truth for active connections
  const tmuxManager = new TmuxManager(config, log, (id) => bridge.hasActiveTerminal(id));
  const attachTokens = new AttachTokens();

  // Register REST routes
  registerStatusRoutes(app, config, tmuxManager);
  registerSessionRoutes(app, discovery, tmuxManager, bridge);
  registerAttachRoutes(app, discovery, tmuxManager, bridge, attachTokens);

  // WebSocket terminal endpoint
  app.get<{
    Params: { sessionId: string };
    Querystring: { cols?: string; rows?: string; token?: string };
  }>(
    "/terminal/:sessionId",
    { websocket: true },
    (socket: WebSocket, request) => {
      const { sessionId } = request.params;
      const cols = parseInt(request.query.cols ?? "", 10) || config.tmux.defaultCols;
      const rows = parseInt(request.query.rows ?? "", 10) || config.tmux.defaultRows;

      // Validate session ID format
      if (!isValidSessionId(sessionId)) {
        socket.close(4400, "Invalid session ID format");
        return;
      }

      // Auth: require a valid attach token (generated by POST /attach)
      // Fallback: PSK via Authorization header (for debugging with wscat)
      const attachToken = request.query.token;
      const authHeader = request.headers.authorization?.slice(7);

      let authorized = false;

      if (attachToken) {
        const tokenSessionId = attachTokens.consume(attachToken);
        if (tokenSessionId === sessionId) {
          authorized = true;
        }
      }

      if (!authorized && authHeader) {
        authorized = verifyPsk(authHeader, config.auth.psk);
      }

      if (!authorized) {
        log.warn({ ip: request.ip, sessionId }, "Unauthorized WS connection attempt");
        socket.close(4401, "Unauthorized");
        return;
      }

      // Find tmux session name
      const tmuxSession = tmuxManager.tmuxName(sessionId);

      // Attach
      bridge
        .attach(sessionId, tmuxSession, socket, cols, rows)
        .catch((err) => {
          log.error({ err, sessionId }, "Failed to attach terminal");
          socket.close(4500, "Failed to attach terminal");
        });
    },
  );

  // Startup
  await discovery.start();
  bridge.start();

  // Reconcile existing tmux sessions + clean orphaned PTYs
  await tmuxManager.reconcile();
  const claudeSessions = await tmuxManager.listClaudeSessions();
  for (const s of claudeSessions) {
    discovery.updateTmuxStatus(s.sessionId, s.tmux.attached ? "active" : "detached");
  }

  // Start listening
  await app.listen({ port: config.port, host: config.host });
  log.info(
    {
      port: config.port,
      host: config.host,
      sessions: discovery.getSessions().length,
    },
    "Claude Relay daemon started",
  );

  // Graceful shutdown
  const shutdown = async (signal: string): Promise<void> => {
    log.info({ signal }, "Shutting down...");
    bridge.stop();
    discovery.stop();
    attachTokens.stop();
    await app.close();
    // Give SIGKILL escalation timers a chance to run
    setTimeout(() => process.exit(0), 6000);
  };

  process.on("SIGINT", () => shutdown("SIGINT"));
  process.on("SIGTERM", () => shutdown("SIGTERM"));
}

main().catch((err) => {
  console.error("Fatal error starting daemon:", err);
  process.exit(1);
});
